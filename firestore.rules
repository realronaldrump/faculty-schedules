// Firestore rules - FIXED VIEWER ACCESS
rules_version = '2';
service cloud.firestore {
  match /databases/{database}/documents {
    function isSignedIn() { return request.auth != null; }

    function userDoc() { return /databases/$(database)/documents/users/$(request.auth.uid); }
    function accessControlDoc() { return /databases/$(database)/documents/settings/accessControl; }
    function hasUserProfile() { return isSignedIn() && exists(userDoc()); }

    // Check user's Firestore profile for a role (supports list/map/string formats)
    function userHasRole(role) {
      return hasUserProfile() && (
        (get(userDoc()).data.roles is list && role in get(userDoc()).data.roles) ||
        (get(userDoc()).data.roles is map && get(userDoc()).data.roles[role] == true) ||
        (get(userDoc()).data.roles is string && get(userDoc()).data.roles == role)
      );
    }

    // Check user's Firestore profile for admin role (supports list/map/string formats)
    function userHasAdminRole() {
      return userHasRole('admin');
    }

    // Direct user action grants (supports wildcard)
    function userHasDirectAction(actionKey) {
      return hasUserProfile() &&
        get(userDoc()).data.actions is map &&
        (
          get(userDoc()).data.actions[actionKey] == true ||
          get(userDoc()).data.actions['*'] == true
        );
    }

    // User overrides (new schema) for action grants
    function userHasOverrideAction(actionKey) {
      return hasUserProfile() &&
        get(userDoc()).data.overrides is map &&
        get(userDoc()).data.overrides.actions is map &&
        (
          get(userDoc()).data.overrides.actions[actionKey] == true ||
          get(userDoc()).data.overrides.actions['*'] == true
        );
    }

    // Role-based action grants from settings/accessControl (supports wildcard)
    function roleHasAction(role, actionKey) {
      return exists(accessControlDoc()) &&
        get(accessControlDoc()).data.rolePermissions is map &&
        get(accessControlDoc()).data.rolePermissions[role] is map &&
        get(accessControlDoc()).data.rolePermissions[role].actions is map &&
        (
          get(accessControlDoc()).data.rolePermissions[role].actions[actionKey] == true ||
          get(accessControlDoc()).data.rolePermissions[role].actions['*'] == true
        );
    }

    function userHasRoleAction(actionKey) {
      return hasUserProfile() && (
        (get(userDoc()).data.roles is list && (
          (get(userDoc()).data.roles.size() > 0 && roleHasAction(get(userDoc()).data.roles[0], actionKey)) ||
          (get(userDoc()).data.roles.size() > 1 && roleHasAction(get(userDoc()).data.roles[1], actionKey)) ||
          (get(userDoc()).data.roles.size() > 2 && roleHasAction(get(userDoc()).data.roles[2], actionKey))
        )) ||
        (get(userDoc()).data.roles is map && (
          (get(userDoc()).data.roles.admin == true && roleHasAction('admin', actionKey)) ||
          (get(userDoc()).data.roles.staff == true && roleHasAction('staff', actionKey)) ||
          (get(userDoc()).data.roles.faculty == true && roleHasAction('faculty', actionKey)) ||
          (get(userDoc()).data.roles.viewer == true && roleHasAction('viewer', actionKey))
        )) ||
        (get(userDoc()).data.roles is string && roleHasAction(get(userDoc()).data.roles, actionKey))
      );
    }

    // Check if user has a specific action permission (direct, override, or role-based)
    function userHasAction(actionKey) {
      return isSignedIn() && (
        isAdmin() ||
        userHasDirectAction(actionKey) ||
        userHasOverrideAction(actionKey) ||
        userHasRoleAction(actionKey)
      );
    }

    // Treat someone as admin if they have a custom claim or admin role
    function isAdmin() {
      return isSignedIn() && (
        // Custom claim on the Auth token
        request.auth.token.admin == true ||
        // Check Firestore user profile roles (supports array or map formats)
        userHasAdminRole()
      );
    }

    // Admin-only access for sensitive operations
    function canWrite() {
      return isAdmin();
    }

    function termIsLocked(termCode) {
      return termCode is string &&
        termCode.size() > 0 &&
        exists(/databases/$(database)/documents/terms/$(termCode)) &&
        (
          get(/databases/$(database)/documents/terms/$(termCode)).data.status == 'archived' ||
          get(/databases/$(database)/documents/terms/$(termCode)).data.locked == true
        );
    }

    function canWriteScheduleTerm(termCode) {
      return termCode is string &&
        termCode.size() > 0 &&
        !termIsLocked(termCode);
    }

    // Settings collection: everyone signed-in can read; only admin writes
    match /settings/{docId} {
      allow read: if isSignedIn();
      allow write: if canWrite();
    }

    // Users profiles: user can read/write own; admin can read/write all
    match /users/{userId} {
      allow read: if isSignedIn() && (request.auth.uid == userId || isAdmin());
      allow write: if canWrite() || (isSignedIn() && request.auth.uid == userId);
    }

    // USER ACTIVITY TRACKING
    // Allow any signed-in user to create their own activity records
    // Keep reads/updates/deletes restricted to admins
    match /userActivity/{id} {
      allow create: if isSignedIn() && request.auth.uid == request.resource.data.userId;
      allow read, update, delete: if canWrite();
    }

    // People collection (faculty, staff, adjunct, students): granular permissions
    match /people/{id} {
      allow read: if isSignedIn();

      // Create operations - check specific action permissions
      allow create: if isAdmin() ||
        userHasAction('directory.faculty.create') ||
        userHasAction('directory.staff.create') ||
        userHasAction('directory.adjunct.create') ||
        userHasAction('directory.student.create');

      // Update operations - check specific action permissions
      allow update: if isAdmin() ||
        userHasAction('directory.faculty.edit') ||
        userHasAction('directory.staff.edit') ||
        userHasAction('directory.adjunct.edit') ||
        userHasAction('directory.student.edit') ||
        userHasAction('crn.update') ||
        userHasAction('missing.data.update');

      // Delete operations - check specific action permissions
      allow delete: if isAdmin() ||
        userHasAction('directory.faculty.delete') ||
        userHasAction('directory.staff.delete') ||
        userHasAction('directory.adjunct.delete') ||
        userHasAction('directory.student.delete');
    }
    // Schedules collection: granular permissions
    match /schedules/{id} {
      allow read: if isSignedIn();
      allow create: if isAdmin() ||
        (userHasAction('schedule.create') && canWriteScheduleTerm(request.resource.data.termCode));
      allow update: if isAdmin() ||
        ((userHasAction('schedule.edit') || userHasAction('schedule.bulk.edit')) && canWriteScheduleTerm(request.resource.data.termCode));
      allow delete: if isAdmin() ||
        (userHasAction('schedule.delete') && canWriteScheduleTerm(resource.data.termCode));
    }

    // Programs collection: granular permissions
    match /programs/{id} {
      allow read: if isSignedIn();
      allow create: if isAdmin() || userHasAction('program.create');
      allow update: if isAdmin() || userHasAction('program.edit') || userHasAction('program.upd.assign');
      allow delete: if isAdmin() || userHasAction('program.delete');
    }

    // Departments collection: granular permissions
    match /departments/{id} {
      allow read: if isSignedIn();
      allow create: if isAdmin() || userHasAction('department.create');
      allow update: if isAdmin() || userHasAction('department.edit');
      allow delete: if isAdmin() || userHasAction('department.delete');
    }

    // Courses collection: granular permissions
    match /courses/{id} {
      allow read: if isSignedIn();
      allow create: if isAdmin() || userHasAction('course.create');
      allow update: if isAdmin() || userHasAction('course.edit');
      allow delete: if isAdmin() || userHasAction('course.delete');
    }

    // Terms collection: granular permissions
    match /terms/{id} {
      allow read: if isSignedIn();
      allow create: if isAdmin() || userHasAction('term.create');
      allow update: if isAdmin() || userHasAction('term.edit');
      allow delete: if isAdmin() || userHasAction('term.delete');
    }

    // Rooms collection: granular permissions
    match /rooms/{id} {
      allow read: if isSignedIn();
      allow create: if isAdmin() || userHasAction('room.create');
      allow update: if isAdmin() || userHasAction('room.edit');
      allow delete: if isAdmin() || userHasAction('room.delete');
    }

    // Temperature monitoring collections: admin writes, signed-in reads
    match /temperatureBuildingSettings/{id} {
      allow read: if isSignedIn();
      allow write: if canWrite();
    }
    match /temperatureDevices/{id} {
      allow read: if isSignedIn();
      allow write: if canWrite();
    }
    match /temperatureDeviceReadings/{id} {
      allow read: if isSignedIn();
      allow write: if canWrite();
    }
    match /temperatureRoomSnapshots/{id} {
      allow read: if isSignedIn();
      allow write: if canWrite();
    }
    match /temperatureImports/{id} {
      allow read: if isSignedIn();
      allow write: if canWrite();
    }

    // Acronyms collection: granular permissions
    match /baylorAcronyms/{id} {
      allow read: if isSignedIn();
      allow create: if isAdmin() || userHasAction('acronym.create');
      allow update: if isAdmin() || userHasAction('acronym.edit');
      allow delete: if isAdmin() || userHasAction('acronym.delete');
    }

    // Change logs
    // - Allow any signed-in user to READ recent changes (dashboard visibility)
    // - Only admins can WRITE
    match /changeLog/{id} {
      allow read: if isSignedIn();
      allow write: if canWrite();
    }
    // Legacy edit history
    // - Allow signed-in read to avoid noisy permission warnings in UI
    // - Only admins can write
    match /editHistory/{id} {
      allow read: if isSignedIn();
      allow write: if canWrite();
    }

    // Import transactions (for preview, commit summary, and rollback)
    match /importTransactions/{id} {
      // Allow admins to read history and details for rollback
      allow read: if isAdmin();
      // Only admins can create/update/delete import transactions
      allow write: if canWrite();
    }

    // Dedupe decisions: allow hygiene tooling to persist "not a duplicate" choices
    match /dedupeDecisions/{id} {
      allow read: if isSignedIn();
      allow write: if isAdmin() || userHasAction('data.hygiene') || userHasAction('data.deduplication');
    }

    // Room grids: allow non-admin writes if the user has explicit action grants
    match /roomGrids/{id} {
      allow read: if isSignedIn();
      allow create: if isAdmin() || userHasAction('roomGrids.save');
      allow update, delete: if isAdmin() || userHasAction('roomGrids.delete');
    }

    // Email List Presets: shared presets that any signed-in user can create/edit
    // Only admins can delete presets
    match /emailListPresets/{id} {
      allow read: if isSignedIn();
      allow create, update: if isSignedIn();
      allow delete: if isAdmin();
    }
  }
}
