// Firestore rules - role + status aware access control
rules_version = '2';
service cloud.firestore {
  match /databases/{database}/documents {
    function isSignedIn() { return request.auth != null; }

    function userDoc() { return /databases/$(database)/documents/users/$(request.auth.uid); }
    function accessControlDoc() { return /databases/$(database)/documents/settings/accessControl; }
    function hasUserProfile() { return isSignedIn() && exists(userDoc()); }

    function roleValueIsTruthy(value) {
      return value == true ||
        (value is int && value != 0) ||
        (value is float && value != 0) ||
        (value is string && value.size() > 0) ||
        (value is map && value.size() > 0) ||
        (value is list && value.size() > 0);
    }

    // Check user's Firestore profile for a role (supports list/map/string formats)
    function userHasRole(role) {
      return hasUserProfile() && (
        (get(userDoc()).data.roles is list && role in get(userDoc()).data.roles) ||
        (get(userDoc()).data.roles is map && roleValueIsTruthy(get(userDoc()).data.roles[role])) ||
        (get(userDoc()).data.roles is string && get(userDoc()).data.roles == role)
      );
    }

    // Check user's Firestore profile for admin role (supports list/map/string formats)
    function userHasAdminRole() {
      return userHasRole('admin');
    }

    function userHasKnownRole() {
      return userHasRole('admin') || userHasRole('staff') || userHasRole('faculty');
    }

    function userStatus() {
      return hasUserProfile() ? get(userDoc()).data.status : null;
    }

    function userIsDisabled() {
      return hasUserProfile() &&
        (get(userDoc()).data.disabled == true || userStatus() == 'disabled');
    }

    function userIsActive() {
      return hasUserProfile() &&
        !userIsDisabled() &&
        (userStatus() == 'active' || (userStatus() == null && userHasKnownRole()));
    }

    function userIsPending() {
      return hasUserProfile() &&
        !userIsDisabled() &&
        (userStatus() == 'pending' || (userStatus() == null && !userHasKnownRole()));
    }

    // Direct user action grants (supports wildcard)
    function userHasDirectAction(actionKey) {
      return hasUserProfile() &&
        get(userDoc()).data.actions is map &&
        (
          get(userDoc()).data.actions[actionKey] == true ||
          get(userDoc()).data.actions['*'] == true
        );
    }

    // User overrides (new schema) for action grants
    function userHasOverrideAction(actionKey) {
      return hasUserProfile() &&
        get(userDoc()).data.overrides is map &&
        get(userDoc()).data.overrides.actions is map &&
        (
          get(userDoc()).data.overrides.actions[actionKey] == true ||
          get(userDoc()).data.overrides.actions['*'] == true
        );
    }

    // Role-based action grants from settings/accessControl (supports wildcard)
    function roleHasAction(role, actionKey) {
      return exists(accessControlDoc()) &&
        get(accessControlDoc()).data.rolePermissions is map &&
        get(accessControlDoc()).data.rolePermissions[role] is map &&
        get(accessControlDoc()).data.rolePermissions[role].actions is map &&
        (
          get(accessControlDoc()).data.rolePermissions[role].actions[actionKey] == true ||
          get(accessControlDoc()).data.rolePermissions[role].actions['*'] == true
        );
    }

    function userHasRoleAction(actionKey) {
      return hasUserProfile() && (
        (userHasRole('admin') && roleHasAction('admin', actionKey)) ||
        (userHasRole('staff') && roleHasAction('staff', actionKey)) ||
        (userHasRole('faculty') && roleHasAction('faculty', actionKey))
      );
    }

    // Check if user has a specific action permission (direct, override, or role-based)
    function userHasAction(actionKey) {
      return isAdmin() ||
        (userIsActive() && (
          userHasDirectAction(actionKey) ||
          userHasOverrideAction(actionKey) ||
          userHasRoleAction(actionKey)
        ));
    }

    // Direct user page grants (supports wildcard)
    function userHasDirectPage(pageId) {
      return hasUserProfile() &&
        get(userDoc()).data.permissions is map &&
        (
          get(userDoc()).data.permissions[pageId] == true ||
          get(userDoc()).data.permissions['*'] == true
        );
    }

    function userHasDirectPageDeny(pageId) {
      return hasUserProfile() &&
        get(userDoc()).data.permissions is map &&
        (
          (pageId in get(userDoc()).data.permissions &&
            get(userDoc()).data.permissions[pageId] == false) ||
          ('*' in get(userDoc()).data.permissions &&
            get(userDoc()).data.permissions['*'] == false)
        );
    }

    // User overrides (new schema) for page grants
    function userHasOverridePage(pageId) {
      return hasUserProfile() &&
        get(userDoc()).data.overrides is map &&
        get(userDoc()).data.overrides.pages is map &&
        (
          get(userDoc()).data.overrides.pages[pageId] == true ||
          get(userDoc()).data.overrides.pages['*'] == true
        );
    }

    function userHasOverridePageDeny(pageId) {
      return hasUserProfile() &&
        get(userDoc()).data.overrides is map &&
        get(userDoc()).data.overrides.pages is map &&
        (
          (pageId in get(userDoc()).data.overrides.pages &&
            get(userDoc()).data.overrides.pages[pageId] == false) ||
          ('*' in get(userDoc()).data.overrides.pages &&
            get(userDoc()).data.overrides.pages['*'] == false)
        );
    }

    // Role-based page grants from settings/accessControl (supports wildcard)
    function roleHasPage(role, pageId) {
      return exists(accessControlDoc()) &&
        get(accessControlDoc()).data.rolePermissions is map &&
        get(accessControlDoc()).data.rolePermissions[role] is map &&
        get(accessControlDoc()).data.rolePermissions[role].pages is map &&
        (
          get(accessControlDoc()).data.rolePermissions[role].pages[pageId] == true ||
          get(accessControlDoc()).data.rolePermissions[role].pages['*'] == true
        );
    }

    function userHasRolePage(pageId) {
      return hasUserProfile() && (
        (userHasRole('admin') && roleHasPage('admin', pageId)) ||
        (userHasRole('staff') && roleHasPage('staff', pageId)) ||
        (userHasRole('faculty') && roleHasPage('faculty', pageId))
      );
    }

    // Check if user has a specific page permission (direct, override, or role-based)
    function userHasPage(pageId) {
      return isAdmin() ||
        (userIsActive() && (
          !userHasDirectPageDeny(pageId) &&
          !userHasOverridePageDeny(pageId) &&
          (userHasDirectPage(pageId) ||
            userHasOverridePage(pageId) ||
            userHasRolePage(pageId))
        ));
    }

    // Treat someone as admin if they have a custom claim or admin role
    function isAdmin() {
      return isSignedIn() && (
        // Custom claim on the Auth token
        request.auth.token.admin == true ||
        request.auth.token.admin == "true" ||
        request.auth.token.admin == 1 ||
        // Check Firestore user profile roles (supports array or map formats)
        userHasAdminRole()
      );
    }

    // Admin-only access for sensitive operations
    function canWrite() {
      return isAdmin();
    }

    function canReadAppData() {
      return isAdmin() || userIsActive() || userIsPending();
    }

    function canManagePeople() {
      return userHasPage('people/directory') ||
        userHasPage('data/import-wizard');
    }

    function canManagePrograms() {
      return userHasPage('people/programs') ||
        userHasPage('data/import-wizard');
    }

    function canManageSchedules() {
      return userHasPage('data/schedule-data') ||
        userHasPage('data/import-wizard');
    }

    function canManageCourses() {
      return userHasPage('data/schedule-data') ||
        userHasPage('data/import-wizard');
    }

    function canManageDepartments() {
      return userHasPage('data/schedule-data') ||
        userHasPage('data/import-wizard');
    }

    function canManageTerms() {
      return userHasPage('admin/settings') ||
        userHasPage('data/import-wizard');
    }

    function canManageRooms() {
      return userHasPage('facilities/spaces') ||
        userHasPage('people/directory') ||
        userHasPage('data/import-wizard');
    }

    function canManageAcronyms() {
      return userHasPage('help/acronyms');
    }

    function canManageRoomGrids() {
      return userHasPage('scheduling/rooms');
    }

    function canManageImports() {
      return userHasPage('data/import-wizard');
    }

    function canManageDataHygiene() {
      return userHasPage('admin/data-hygiene');
    }

    function termIsLocked(termCode) {
      return termCode is string &&
        termCode.size() > 0 &&
        exists(/databases/$(database)/documents/terms/$(termCode)) &&
        (
          get(/databases/$(database)/documents/terms/$(termCode)).data.status == 'archived' ||
          get(/databases/$(database)/documents/terms/$(termCode)).data.locked == true
        );
    }

    function canWriteScheduleTerm(termCode) {
      return termCode is string &&
        termCode.size() > 0 &&
        !termIsLocked(termCode);
    }

    function isSelf(userId) {
      return isSignedIn() && request.auth.uid == userId;
    }

    function isEmptyOrMissingMap(field) {
      return !(field in request.resource.data) ||
        (request.resource.data[field] is map && request.resource.data[field].size() == 0);
    }

    function isSelfProfileCreateAllowed(userId) {
      return isSelf(userId) &&
        request.resource.data.uid == request.auth.uid &&
        request.resource.data.email == request.auth.token.email &&
        request.resource.data.status == 'pending' &&
        request.resource.data.roles is list &&
        request.resource.data.roles.size() == 0 &&
        request.resource.data.disabled != true &&
        isEmptyOrMissingMap('permissions') &&
        isEmptyOrMissingMap('actions') &&
        (!(request.resource.data.overrides is map) ||
          ((request.resource.data.overrides.pages is map && request.resource.data.overrides.pages.size() == 0) &&
           (request.resource.data.overrides.actions is map && request.resource.data.overrides.actions.size() == 0)));
    }

    function isSelfProfileUpdateAllowed(userId) {
      return isSelf(userId) &&
        request.resource.data.diff(resource.data).changedKeys()
          .hasOnly(['displayName', 'photoURL', 'lastLoginAt', 'updatedAt']);
    }

    function isNonEmptyString(value) {
      return value is string && value.size() > 0;
    }

    function isValidSpaceKey(value) {
      return value is string && value.matches('^[A-Z0-9_]+:[A-Z0-9./-]+$');
    }

    function isValidSpaceRecord(data) {
      return isValidSpaceKey(data.spaceKey) &&
        isNonEmptyString(data.buildingCode) &&
        data.buildingCode.matches('^[A-Z0-9_]+$') &&
        isNonEmptyString(data.spaceNumber) &&
        data.spaceNumber.matches('^[A-Za-z0-9./-]+$');
    }

    function isLegacySpaceRecord(data) {
      return !(data.spaceKey is string) || data.spaceKey.size() == 0;
    }

    function onlyUpdatesSpaceStatus() {
      return request.resource.data.diff(resource.data).changedKeys()
        .hasOnly(['isActive', 'deletedAt', 'updatedAt']);
    }

    // Settings collection: active users can read; only admin writes
    match /settings/{docId} {
      allow read: if canReadAppData();
      allow write: if canWrite();
    }

    // Users profiles: user can read/write own; admin can read/write all
    match /users/{userId} {
      allow read: if isSignedIn() && (request.auth.uid == userId || isAdmin());
      allow create: if canWrite() || isSelfProfileCreateAllowed(userId);
      allow update: if canWrite() || isSelfProfileUpdateAllowed(userId);
      allow delete: if canWrite();
    }

    // People collection (faculty, staff, adjunct, students): granular permissions
    match /people/{id} {
      allow read: if canReadAppData();

      // Create operations - allow users with people directory access (or import wizard)
      allow create: if canManagePeople();

      // Update operations - allow users with people directory access (or import wizard)
      allow update: if canManagePeople();

      // Delete operations - allow users with people directory access (or import wizard)
      allow delete: if canManagePeople();
    }
    // Schedules collection: granular permissions
    match /schedules/{id} {
      allow read: if canReadAppData();
      allow create: if canManageSchedules() &&
        canWriteScheduleTerm(request.resource.data.termCode);
      allow update: if canManageSchedules() &&
        canWriteScheduleTerm(request.resource.data.termCode);
      allow delete: if canManageSchedules() &&
        canWriteScheduleTerm(resource.data.termCode);
    }

    // Programs collection: granular permissions
    match /programs/{id} {
      allow read: if canReadAppData();
      allow create: if canManagePrograms();
      allow update: if canManagePrograms();
      allow delete: if canManagePrograms();
    }

    // Departments collection: granular permissions
    match /departments/{id} {
      allow read: if canReadAppData();
      allow create: if canManageDepartments();
      allow update: if canManageDepartments();
      allow delete: if canManageDepartments();
    }

    // Courses collection: granular permissions
    match /courses/{id} {
      allow read: if canReadAppData();
      allow create: if canManageCourses();
      allow update: if canManageCourses();
      allow delete: if canManageCourses();
    }

    // Terms collection: granular permissions
    match /terms/{id} {
      allow read: if canReadAppData();
      allow create: if canManageTerms();
      allow update: if canManageTerms();
      allow delete: if canManageTerms();
    }

    // Rooms collection: granular permissions
    // Admins have FULL access without validation; non-admins must pass validation
    match /rooms/{id} {
      allow read: if canReadAppData();
      allow create: if isAdmin() ||
        (canManageRooms() &&
          isValidSpaceRecord(request.resource.data) &&
          id == request.resource.data.spaceKey);
      allow update: if isAdmin() ||
        (canManageRooms() &&
          (isValidSpaceRecord(request.resource.data) ||
            (isLegacySpaceRecord(resource.data) && onlyUpdatesSpaceStatus())));
      allow delete: if canManageRooms();
    }

    // Temperature monitoring collections: all authenticated users can read/write
    match /temperatureBuildingSettings/{id} {
      allow read, write: if canReadAppData();
    }
    match /temperatureDevices/{id} {
      allow read, write: if canReadAppData();
    }
    match /temperatureDeviceReadings/{id} {
      allow read, write: if canReadAppData();
    }
    match /temperatureRoomSnapshots/{id} {
      allow read, write: if canReadAppData();
    }
    match /temperatureImports/{id} {
      allow read, write: if canReadAppData();
    }
    match /temperatureImportJobs/{id} {
      allow read, write: if canReadAppData();
    }
    match /temperatureRoomAggregates/{id} {
      allow read, write: if canReadAppData();
    }

    // Acronyms collection: granular permissions
    match /baylorAcronyms/{id} {
      allow read: if canReadAppData();
      allow create: if canManageAcronyms();
      allow update: if canManageAcronyms();
      allow delete: if canManageAcronyms();
    }

    // Change logs
    // - Allow any signed-in user to READ recent changes (dashboard visibility)
    // - Only admins can WRITE
    match /changeLog/{id} {
      allow read: if canReadAppData();
      allow write: if canWrite();
    }
    // Legacy edit history
    // - Allow signed-in read to avoid noisy permission warnings in UI
    // - Only admins can write
    match /editHistory/{id} {
      allow read: if canReadAppData();
      allow write: if canWrite();
    }

    // Import transactions (for preview, commit summary, and rollback)
    match /importTransactions/{id} {
      allow read: if canManageImports();
      allow write: if canManageImports();
    }
    // Import runs + row lineage (idempotency tracking)
    match /importRuns/{id} {
      allow read: if canManageImports();
      allow write: if canManageImports();
    }
    match /importRowLineage/{id} {
      allow read: if canManageImports();
      allow write: if canManageImports();
    }

    // Dedupe decisions: allow hygiene tooling to persist "not a duplicate" choices
    match /dedupeDecisions/{id} {
      allow read: if canReadAppData();
      allow write: if canManageDataHygiene();
    }

    // Room grids: allow writes for users who can access room scheduling tools
    match /roomGrids/{id} {
      allow read: if canReadAppData();
      allow create: if canManageRoomGrids();
      allow update: if canManageRoomGrids();
      allow delete: if canManageRoomGrids();
    }

    // Email List Presets: shared presets that any signed-in user can create/edit
    // Only admins can delete presets
    match /emailListPresets/{id} {
      allow read: if canReadAppData();
      allow create, update: if canReadAppData();
      allow delete: if isAdmin();
    }
  }
}
